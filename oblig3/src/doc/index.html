<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Inf-2301-2016.2: Reliable Transport Protocol Network Simulator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="uit-logo-eng.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Inf-2301-2016.2
   &#160;<span id="projectnumber">Mandatory Assignment 3</span>
   </div>
   <div id="projectbrief">Computer communication and security, Fall 2016</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Reliable Transport Protocol Network Simulator </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Overview">Overview</a></li>
<li class="level1"><a href="#Compilation">Compilation</a></li>
<li class="level1"><a href="#doc">Documentation</a></li>
<li class="level1"><a href="#where">Where should I start?</a><ul><li class="level2"><a href="#make">GNU-Make</a></li>
<li class="level2"><a href="#vs">Visual Studio</a></li>
</ul>
</li>
<li class="level1"><a href="#The">Network simulator application</a><ul><li class="level2"><a href="#srand">Random Number Generator Seeding</a></li>
<li class="level2"><a href="#message_count">Number of Generated Messages</a></li>
<li class="level2"><a href="#bidirectional">Bidirectional</a></li>
<li class="level2"><a href="#loss_corrupt_probs">Loss- and Corruption-probability</a></li>
<li class="level2"><a href="#nw_delay">Average Network Transmission Delay</a></li>
<li class="level2"><a href="#nw_stddev">Network Transmission Delay Relative Variance</a></li>
<li class="level2"><a href="#gen_delay">Application Level Data Generation Delay</a></li>
<li class="level2"><a href="#trace">Trace Level</a></li>
</ul>
</li>
<li class="level1"><a href="#app_layer">Application Layer Functionality</a></li>
<li class="level1"><a href="#nw_layer">Network Layer Functionality</a></li>
<li class="level1"><a href="#timer_objects">Timer Objects</a></li>
</ul>
</div>
<div class="textblock"><p>Welcome to the documentation pages for the RTP network simulator. These documentation pages were generated purely out of the documentation comments found in the source code using the <a href="http://www.stack.nl/~dimitri/doxygen/index.html">Doxygen</a> documentation generator.</p>
<h1><a class="anchor" id="Overview"></a>
Overview</h1>
<p>In this assignment you are to implement the transport layer that is found between the application and the network layer in an OSI-stack networking architecture. Since the transport layer is already implemented in the core of the networking stack embedded in the operating system kernel, it is rather hard to actually implement the transport layer functionality for a real network connection. Because of the you are presented with the RTP network simulator that simulates a network connection. This also has the added benefit that we can directly control how many packages will be lost in transmission, how many packages get corrupted and how long a transmission takes.</p>
<h1><a class="anchor" id="Compilation"></a>
Compilation</h1>
<p>The source code is written entirely using the C programming language and it is expected of your that you implement the missing parts of the transport layer using the appropoate function entry points in the source code.</p>
<p>Since the network simulator does not depend on any external library besides the C-runtime library, this application should be compilable on most modern platforms, but during development particular emphasis has been on making the code compilable on moder Linux-distributions as well as modern Windows operating systems.</p>
<h1><a class="anchor" id="doc"></a>
Documentation</h1>
<p>If you click on the <code>Files</code> button in the navigation bar on the top of this page, you will be presented with a list of files containing documentation. You are welcome to look at all documentation pages, but the following pages will be the most interesting for you: </p><ul>
<li>
<a class="el" href="diagnostics_8h.html" title="Contains the diagnostic API to provide diagnostic printing to the standard output stream...">diagnostics.h</a> </li>
<li>
<a class="el" href="timer_8h.html" title="Contains the API declarations for the timer objects.">timer.h</a> </li>
<li>
<a class="el" href="transport__layer_8h.html" title="Contains the externally visible API of the transport layer abstraction in the OSI-stack.  Students are resposible of implementing most of the functions declared in this file. ">transport_layer.h</a> </li>
<li>
<a class="el" href="transport__layer_8c.html" title="Contains the code implementation for the transport layer abstraction in the OSI-stack.  Students are required to implement the provided stubs within this file according to their own understanding of the transport layer. ">transport_layer.c</a> </li>
<li>
<a class="el" href="transport__package_8h.html" title="Contains the externally visible declarations for the transport packages abstraction.">transport_package.h</a> </li>
<li>
<a class="el" href="transport__package__impl_8h.html" title="Contains the implementation details of transport packages.  Students are required to redefine the imp...">transport_package_impl.h</a> </li>
</ul>
<h1><a class="anchor" id="where"></a>
Where should I start?</h1>
<p>For this assignment, you are required to fully implement the functions within the <a class="el" href="transport__layer_8c.html" title="Contains the code implementation for the transport layer abstraction in the OSI-stack.  Students are required to implement the provided stubs within this file according to their own understanding of the transport layer. ">transport_layer.c</a>, <a class="el" href="transport__package__impl_8h.html" title="Contains the implementation details of transport packages.  Students are required to redefine the imp...">transport_package_impl.h</a> and transport_package.c files. Changing any other part of the simulator should not be necessary for this assignment. You are welcome to look at the implementation of the network simulator if you like, but do not worry if you cannot make heads or tails of it, in-depth knowledge of the implementational details of the rest of the network simulator is not required. Nevertheless, all functions that are available through header files in this code-base are documented in these documentation pages.</p>
<p>It is recommended to first start with the assumption of a perfect network environment, i.e. an environment without loss, corruption, or delay variation. Gradually extend your code to deal with tranmission timeouts, corrupted packages, and out-of-sequence packages.</p>
<p>The <a class="el" href="transport__layer_8h.html#a1cb72211219b09c8f91a14681c6b7111" title="Pushes application layer data from the receiving transport layer to the application layer above it in...">osi_tp2app</a> and <a class="el" href="transport__layer_8h.html#a664fb871a5465e582ef4ad30c8d9946e" title="Pushes a transport package from the transport layer to the underlying network layer in the OSI-stack...">osi_tp2nw</a> are the functions you must use to push data upwards and downwards in the OSI-stack.</p>
<h2><a class="anchor" id="make"></a>
GNU-Make</h2>
<p>In the <code>src</code> subfolder, you will find the source code for the application, together with a <code>Makefile</code> containing instructions for GNU-make utility to compile the source code using the GCC compiler. Navigate to the <code>src</code> subfolder and execute the following command: </p><div class="fragment"><div class="line">make</div></div><!-- fragment --><p> You may also re-generate the Doxygen documentation pages on your own, if you feel the need, or employ documentation comments in your code that are recognized by the doxygen generator. For that purpose invoke the special build target for the documentation in using the same Makefile. </p><div class="fragment"><div class="line">make doc</div></div><!-- fragment --><h2><a class="anchor" id="vs"></a>
Visual Studio</h2>
<p>The source code also contains a solution file together with a Visual C/C++ project file. You can open up the Solution file found in the root folder of the hand-out in Visual Studio. In the Menu bar select <code>Build</code> and then <code>Build Solution</code> to compile your program. Note that Visual Studio will provide you with first class IntelliSense support as well as very advanced Debugging capability. It is however, up to you whether you want to make use of these features or not.</p>
<p><b>Note</b> that the Visual Studio Build process (MSBuild) will create a <code>bin</code> folder next to the <code>src</code> folder and place the binaries there. Visual Studio will automatically attempt to run the doxygen command to produce the documentation pages as well, and will issue a warning message in case you do not have doxygen installed.</p>
<h1><a class="anchor" id="The"></a>
Network simulator application</h1>
<p>When executed the network simulator application will ask a series of questions to set up the simulated network environment.</p>
<h2><a class="anchor" id="srand"></a>
Random Number Generator Seeding</h2>
<p>The C-runtime library includes a simple pseudo-random number generator. This PRNG generates random numbers based on a configurable seed value. It is customary to seed the PRNG with the current time or some other relatively random number to get different random numbers each time the application is run.</p>
<p>In your case, however, there might be situation where you might want to replay the exact same sequence of events you encountered in a previous run. Therefore you are presented with the option to enter a specific seed value that you want. Entering nothing will seed with <code>0U</code> (zero) and entering <code>t</code> will seed the PRNG with the current local time on your computer. When time is used, the calculated seed value is displayed for convenience.</p>
<h2><a class="anchor" id="message_count"></a>
Number of Generated Messages</h2>
<p>The simulator will terminate after the specified amount of messages has been sent and received from each application layer. In a single-directional environment the application layer in endpoint A will send the sepcified amount to endpoint B and B will wait to receive the specifed amount of messages. In a bi-directional environment, both application layers will send the specified amount of messages to the other endpoint.</p>
<h2><a class="anchor" id="bidirectional"></a>
Bidirectional</h2>
<p>While you are required to implement a bi-directional communication channel, it might be easier to start with a solution that reliably transmits data only in one direction. Enter <code>y</code> for yes, and <code>n</code> for no.</p>
<h2><a class="anchor" id="loss_corrupt_probs"></a>
Loss- and Corruption-probability</h2>
<p>The network simulator will at the network layer decide whether a package to transmit should be lost or corrupted during transmission. The simulator will prompt your to specify the probability of both loss and corruption of a package. You have to implement a reliable transport protocol that can deal with both, but as a start it is easier to be able to turn either loss or corruption on or off (by specifying <code>0.0</code> to turn it off).</p>
<p>Note that probabilities are expressed as relative probabilities, meaning a value between <code>0.0</code> and <code>1.0</code>. E.g. A value of <code>0.1</code> will result in a 10% probability, whereas <code>0.97</code> will result in a 97% probability, and <code>1.0</code> will result in certainty.</p>
<h2><a class="anchor" id="nw_delay"></a>
Average Network Transmission Delay</h2>
<p>Specify the mean value in ticks for how long a transmission should take on average. Whenever a transport package is transmitted on the network layer, the network layer calculates the amount of time it should take for the package to be transmitted. The actual calculated value is normally distributed around the mean value you specify. In essence this means that the actual transmission time will vary, but very likely be close to the average you specify. If you like, you may have a look at <a href="https://en.wikipedia.org/wiki/Normal_distribution">Normal Distribution</a> for more information on normal distributions, but this is a topic best suited for your Statistics class and not of much relevance here, as this functionality already is completely implemented.</p>
<h2><a class="anchor" id="nw_stddev"></a>
Network Transmission Delay Relative Variance</h2>
<p>Specify the relative variance from the previously specified average value that you want in your normal distribution. The less the value you specify, the less variance around your mean value you will get. If you specify <code>0.0</code>, the normal distribution will always return your specified mean value.</p>
<p>If the mean value is set to <code>100</code>, specifying a relative variance of <code>0.1</code> (or 10%) will in most cases yield a random value between <code>90</code> and <code>110</code>. For a mean value of <code>200</code> and a relative variance of <code>0.15</code>, the resulting values will in most cases lie between <code>170</code> and <code>230</code>.</p>
<h2><a class="anchor" id="gen_delay"></a>
Application Level Data Generation Delay</h2>
<p>The application layer will at random intervals decice to send more data through the network channel. As with the network transmission delay, the application layer delay is also a normally distributed random value. The application calculates a value that is optimal in your situation based on the specified loss and corruption probabilities as well as the network transmission delay. Please contact the TAs, if this calculation leads to problems.</p>
<p>For reference, the Application Layer Data Generation Delay uses a normal distribution with the announced mean value and a relative variance of 10%.</p>
<h2><a class="anchor" id="trace"></a>
Trace Level</h2>
<p>You can specify the verbosity of the application. The application will only print diagnost message that on or above the level that you specify.</p>
<p>Specifying the Warning level, will cause Warning, Error and Critical messages to be printed, but Informational, Verbose and Debug messages will be supressed. Therefore, specifying the Debug level will always cause every diagnostic message to be printed, but you might feel that using this level will unnecessarily clutter your output window.</p>
<h1><a class="anchor" id="app_layer"></a>
Application Layer Functionality</h1>
<p>A sending application layer will at normally distributed random intervals decide to generate a message containing random binary data. It will then push that data down to the underlying transport layer and expects that data to be transmitted in sequence to the other endpoint. For verification puposes, the application layers also share their data directly which in this case is only possible becuase both application layers live inside the same process in the application and share the same memory address space, this would not be possible a real networked situation.</p>
<p>A receiving application layer will receive data from its underlying transport layer as the transport layer pushes the data upwards, and the application layer will expect the data to arrive in sequence. The received bytes are byte-wise compared to the expected data, and an error will be generated if they do not match.</p>
<h1><a class="anchor" id="nw_layer"></a>
Network Layer Functionality</h1>
<p>The network layer will wait for the transport layer to push transport packages downwards in the OSI-stack. It will then use its configured probabilities to decide whether the package should be lost or corrupted. After that, it will use its normal distribution for the network delay to decide how many ticks should pass before the package arrives and the remote network layer and sets a timer accordingly.</p>
<p>When a transport package is received at the network layer, it is simply pushed upwards in the OSI-stack and handed over to the Transport Layer.</p>
<h1><a class="anchor" id="timer_objects"></a>
Timer Objects</h1>
<p>In order to make the application behave the same if the same configuration values are specified, a decision was made to write the entire code-base around a tick-based system instead of an actual time-based system. All timeouts and delay values are specified as ticks.</p>
<p>The main function of the network simulator, features a continous loop that for the most part only calls the <a class="el" href="timer_8h.html#a8a0dc32d3f35ac32d0370ca776f56034" title="Advances all active timer objects one tick ahead and invokes the callback function for expired timers...">timer_tickall</a> function. Each iteration through that loop can be considered as one tick.</p>
<p>This also implies that every entity in the simulator, i.e. a transport package, or a layer in one of the OSI-stacks, gets to perform exactly one operation during a single tick.</p>
<p>For you as an implementor, this is really good news. Dealing with time in computer science is in most cases fairly complex and hard to do deterministically. This tick-based system should be fairly easy to use and is guaranteed to behave deterministically and without influence from what else you are running on your computer. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
